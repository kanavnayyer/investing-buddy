package com.awesome.investingbuddy.ui

import android.content.ContentValues
import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.awesome.investingbuddy.R
import com.awesome.investingbuddy.adapters.NoteAdapter
import com.awesome.investingbuddy.databinding.DialogAddItemBinding
import com.awesome.investingbuddy.databinding.FragmentNotesBinding
import com.awesome.investingbuddy.models.Note
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query


class NotesFragment : Fragment() {
    // TODO: Rename and change types of parameters

    private lateinit var noteAdapter: NoteAdapter
    private lateinit var db: FirebaseFirestore
    private lateinit var binding: FragmentNotesBinding// Replace with your binding class
    // Initialize binding and other variables here
    private  lateinit var recyclerView: RecyclerView
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?,
    ): View? {
        // Inflate the layout for this fragment
        binding=FragmentNotesBinding.inflate(layoutInflater)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        db = FirebaseFirestore.getInstance()
        recyclerView=binding.recyclerView
        recyclerView.layoutManager= GridLayoutManager(requireContext(),2)




        binding.fabAdd.setOnClickListener {
            showAddItemDialog()

        }
        noteAdapter = NoteAdapter(emptyList()) // Initially, the adapter is empty
        recyclerView.adapter = noteAdapter
        setUpFirestoreListener()
    }

    private fun showAddItemDialog() {
        val dialogBuilder = AlertDialog.Builder(requireContext())
        val inflater = LayoutInflater.from(requireContext())
        val dialogBinding = DialogAddItemBinding.inflate(inflater)
        dialogBuilder.setView(dialogBinding.root)

        val alertDialog = dialogBuilder.create()
        alertDialog.show()

        // Initialize views from binding
        val etTitle = dialogBinding.etTitle
        val etDescription = dialogBinding.etDescription
        val tvTitleCounter = dialogBinding.tvTitleCounter
        val tvDescriptionCounter = dialogBinding.tvDescriptionCounter
        val btnCancel = dialogBinding.btnCancel
        val btnSave = dialogBinding.btnSave

        // Set initial character counters
        // Set initial character counters
        tvTitleCounter.text = "30 characters remaining"
        tvDescriptionCounter.text = "500 characters remaining"

        // Text change listeners for character counters
        etTitle.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                val remainingChars = 30 - s?.length!! ?: 0
                tvTitleCounter.text = "$remainingChars characters remaining"
            }

            override fun afterTextChanged(s: Editable?) {}
        })

        etDescription.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                val remainingChars = 500 - s?.length!! ?: 0
                tvDescriptionCounter.text = "$remainingChars characters remaining"
            }

            override fun afterTextChanged(s: Editable?) {}
        })


        // Save button click listener
        btnSave.setOnClickListener {
            val title = etTitle.text.toString().trim()
            val description = etDescription.text.toString().trim()
            val userEmail = "${ FirebaseAuth.getInstance().currentUser?.email}".trim()
            val createdAt = System.currentTimeMillis().toString()


            if (title.isEmpty() || description.isEmpty() || userEmail.isEmpty()) {
                Toast.makeText(requireContext(), "Please fill in all fields", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }

            // Create a new Note object with autogenerated ID
            val note = Note(
                id = "",  // Firestore will generate ID automatically
                title = title,
                description = description,
                userEmail = userEmail, // Add user's email to the Note object

            )

            // Add the note to Firestore
            db.collection("notes")
                .add(note)
                .addOnSuccessListener { documentReference ->
                    // Update the note's ID with the generated Firestore document ID
                    val updatedNote = note.copy(id = documentReference.id)
                    updateNoteInFirestore(updatedNote)
                    alertDialog.dismiss()
                }
                .addOnFailureListener { e ->
                    Toast.makeText(
                        requireContext(),
                        "Failed to add note: ${e.message}",
                        Toast.LENGTH_SHORT
                    ).show()
                }
        }

        // Cancel button click listener
        btnCancel.setOnClickListener {
            alertDialog.dismiss()
        }
    }

    private fun updateNoteInFirestore(note: Note) {
        db.collection("notes")
            .document(note.id)
            .set(note)
            .addOnSuccessListener {
                Toast.makeText(requireContext(), "Note added successfully", Toast.LENGTH_SHORT)
                    .show()
            }
            .addOnFailureListener { e ->
                Toast.makeText(
                    requireContext(),
                    "Failed to update note: ${e.message}",
                    Toast.LENGTH_SHORT
                ).show()
            }
    }
    private fun setUpFirestoreListener() {
        val currentUser = FirebaseAuth.getInstance().currentUser
        currentUser?.let { user ->
            db.collection("notes")
                .whereEqualTo("userEmail", user.email)

                .addSnapshotListener { snapshot, exception ->
                    if (exception != null) {
                        Log.e(ContentValues.TAG, "Error fetching notes: $exception")
                        return@addSnapshotListener
                    }

                    if (snapshot != null) {
                        val notesList = mutableListOf<Note>()

                        for (doc in snapshot.documents) {
                            val note = doc.toObject(Note::class.java)
                            note?.let {
                                notesList.add(it)
                            }
                        }

                        noteAdapter.updateData(notesList)
                    }
                }
        }
    }



}
